#!/usr/bin/env python

import transMapProgSetup
from optparse import OptionParser
from pycbio.sys import fileOps, procOps
from transMap import genomeDefs, setTMPDIR, getTmpExt, runCmds, copyFile
from transMap.genomeDefs import ChainType
from transMap.transMap import TransMap,Chroms

class CmdOpts(object):
    usage = """%prog [options] genomeDefsPickle srcDb destDb chainType annSetType cdnaPart clusterDir mappedPsl"""
    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--chrom", dest="chroms", action="append", default=None,
                          help="only process this destination chrom, maybe repeated")
        parser.add_option("--firstChrom", dest="firstChrom", action="store", default=None,
                          help="destDb start destination chrom in reverse size sort list")
        parser.add_option("--lastChrom", dest="lastChrom", action="store", default=None,
                          help="destDb last destination chrom in reverse size sort list")
        parser.add_option("--keep", dest="keep", action="store_true", default=False,
                          help="keep temporary files")
        (opts, args) = parser.parse_args()
        if len(args) != 8:
            parser.error("wrong number of arguments: got " + str(len(args)) + ", expect 8")
        (self.genomeDefsPickle, self.srcDb, self.destDb, self.chainType, self.annSetType, self.cdnaPart, self.clusterDir, self.mappedPsl) = args
        self.__dict__.update(opts.__dict__)
        if ((opts.firstChrom != None) or (opts.lastChrom != None)) and ((opts.firstChrom == None) or (opts.lastChrom == None)):
            parser.error("must specified either both or neither of --firstChrom and --lastChrom")
        self.chainType = genomeDefs.ChainType(self.chainType)
        self.annSetType = genomeDefs.AnnSetType(self.annSetType)

def bldChroms(opts, dest2bit):
    chromSet = None
    if (opts.chroms != None) or (opts.firstChrom != None):
        chromSet = []
        if opts.chroms != None:
            chromSet.extend(opts.chroms)
        if (opts.firstChrom != None):
            chroms = Chroms(dest2Bit)
            chromSet.extend(chroms.getRange(opts.firstChrom, opts.lastChrom))
    return chromSet

# memory optimizations:
#   - limit cDNA fasta sequences read by pslRecalcMatch step to those that aligned
#   - limit chains read by netChainSubset, since it reads all chains into memory

opts = CmdOpts()
tmpDir = setTMPDIR()
tmpExt = getTmpExt()

###
# skip if already completed
###
if os.path.exists(opts.mappedPsl):
    sys.stderr.write("Note: output already exists, skipping: " + opts.mappedPsl + "\n")
    sys.exit(0)

gdefs = genomeDefs.load(opts.genomeDefsPickle)
transMap = TransMap(None, gdefs, ".", None, opts.clusterDir)
srcDb = gdefs.dbs[opts.srcDb]
destDb = gdefs.dbs[opts.destDb]

##
# input
##

# chains
chainsSet = srcDb.destChainsSets.getChainsSet(destDb)

# cDNA
srcPsl = transMap.getClusterSrcPsl(srcDb, opts.annSetType, opts.cdnaPart)
srcFa = transMap.getClusterSrcFa(srcDb, opts.annSetType, opts.cdnaPart)

# genome sequence
relTargetSeqs = destDb.name + "/" + destDb.name + ".2bit"
targetSeqs = "/scratch/data/" + relTargetSeqs
if not os.path.exists(targetSeqs):
    targetSeqs = "/hive/data/genomes/" + relTargetSeqs
if not os.path.exists(targetSeqs):
    raise Exception("can't find genome: " + targetSeqs)
if (opts.chroms != None) or (opts.firstChrom != None):
    chroms = bldChroms(opts, targetSeqs)
else:
    chroms = None


##
# intermediate output
##
chainSubsetTmp = tmpDir + "/transmap.chain" + tmpExt
pslRawTmp = tmpDir + "/transmap.psl" + tmpExt
mapInfoRawTmp = tmpDir+ "/transmap.mapinfo.raw" + tmpExt
pslPreFiltTmp = tmpDir+ "/transmap.psl.prefilt" + tmpExt
mapInfoPreFiltTmp = tmpDir+ "/transmap.mapinfo.prefilt" + tmpExt
pslFiltTmp = tmpDir+ "/transmap.psl.filt" + tmpExt
mapInfoFiltTmp = tmpDir+ "/transmap.mapinfo.filt" + tmpExt
pslRecalcTmp = tmpDir+ "/transmap.psl.recalc" + tmpExt

tmpFiles = (chainSubsetTmp, pslRawTmp, mapInfoRawTmp, pslPreFiltTmp, mapInfoPreFiltTmp, pslFiltTmp, mapInfoFiltTmp, pslRecalcTmp)

# output
outPrefix = os.path.splitext(fileOps.uncompressedBase(opts.mappedPsl))[0]
outPslTmp = opts.mappedPsl + tmpExt
outMapInfo = outPrefix + ".mapinfo"

###
# Get the chains to use.   Pre-filter with overlapSelect to reduce
# memory requirements of pslMap and netChainSubset.
###
chains = chainsSet.getSupportingType(opts.chainType)
if chains == None:
    chainsSet.dump(sys.stderr)
    raise Exception("No chains found compatible with type: "+ str(opts.chainType))

chainPreFiltCmds = []
chainPreFiltCmds.append(["overlapSelect", "-inFmt=chainq", srcPsl, chains.chainFile, "/dev/stdout"])
if chroms != None:
    chainPreFiltCmds.append(["chainFilter", "-noHap", "-t=" + ",".join(chroms), "/dev/stdin"])
else:
    chainPreFiltCmds.append(["chainFilter", "-noHap", "stdin"])
runCmds(chainPreFiltCmds, stdout=chainSubsetTmp)

chainFilterCmds = []
if (opts.chainType == ChainType.all) or (opts.chainType == ChainType.rbest):
    # no filtering
    chainInFileRef = chainSubsetTmp
else:
    # syn filtering
    chainFilterCmds.append(["netFilter", "-syn", "-noHap", chains.netFile])
    chainFilterCmds.append(["netChainSubset", "-wholeChains", "-skipMissing", "-verbose=0", "/dev/stdin", chainSubsetTmp, "/dev/stdout"])
    chainInFileRef = "/dev/stdin"

###
# map alignments, removing duplicate psls with same query/target range, which
# are noise and make it difficult to select the right mapInfo records
##
pslMap = ["pslMap", "-chainMapFile", "-mapInfo="+mapInfoRawTmp, srcPsl, chainInFileRef, pslRawTmp]
runCmds(chainFilterCmds +[pslMap])
preFilt = ["pslMapInfoPreFilter", "-chainSubset="+str(opts.chainType), pslRawTmp, mapInfoRawTmp, pslPreFiltTmp, mapInfoPreFiltTmp]
runCmds(preFilt)

###
# Filter before pslRecalcMatch to avoid it take hours when there are huge
# number of mappings (say > 50,000 for one refseq in mapped to monDom5).
# Target sort speeds up pslRecalcMatch.
##
pslCDnaFilter = ["pslCDnaFilter", "-verbose=0", "-minQSize=" + str(transMap.minQSize), "-maxAligns=" + str(transMap.maxAligns),
                 "-minCover=" + str(transMap.minCover), "-globalNearBest=" + str(transMap.getGlobalNearBestPreFilter(destDb)), pslPreFiltTmp, "stdout"]
qsortCmd = ["sort","-k","10,10"]
tsortCmd = ["sort","-k","14,14", "-k", "16,16n"]
runCmds([qsortCmd, pslCDnaFilter, tsortCmd], stdout=pslFiltTmp)

# select subset of alignments and get matching mapInfo file
pslMapInfoSelect = ["pslMapInfoSelect", mapInfoPreFiltTmp, pslFiltTmp, mapInfoFiltTmp]
runCmds(pslMapInfoSelect)

###
# calculate match stats; qsort here, just to make runFilter qsort a bit quicker.
##
pslRecalcMatch = ["pslRecalcMatch", "-ignoreQUniq", pslFiltTmp, targetSeqs,
                  transMap.getClusterSrcFa(srcDb, opts.annSetType, opts.cdnaPart), "/dev/stdout"]

qsort = ["sort", "-k","10,10", "-k", "12,12n", "-k", "13,13n"]
runCmds([pslRecalcMatch, qsort], stdout=pslRecalcTmp)

# install files, psl last and atomic
fileOps.ensureFileDir(opts.mappedPsl)
copyFile(mapInfoFiltTmp, outMapInfo)
copyFile(pslRecalcTmp, outPslTmp)
os.rename(outPslTmp, opts.mappedPsl)

if opts.keep:
    sys.stderr.write("Note: keeping temporary files:\n")
    for f in tmpFiles:
        sys.stderr.write("\t" + f + "\n")
else:
    for f in tmpFiles:
        os.unlink(f)
