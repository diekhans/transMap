#!/usr/bin/env python

import transMapProgSetup  # noqa: F401
import sys
import argparse
import sqlite3
# from transMap.genomeDefs import AnnSetType
from pycbio.hgdata import hgDb
from transMap.genomeDefs import GenomesDbTables, ChainsTbl
from transMap.chainsFinder import ChainsFinder
from transMap.phyloTrees import PhyloDistances


verbose = False


def parseArgs():
    desc = """Get information about genomes.  This finds all available chains and
    source data for all active genomes.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--verbose", action="store_true", default=False,
                        help="""verbose tracing""")
    parser.add_argument("--hgDb", action="append", default=None, dest="hgDbs",
                        help="""limit to these databases for testing, maybe repeated""")
    parser.add_argument("--tree", dest="trees", action="append", default=[],
                        help="set branch lengths from this tree file, maybe repeated.  The distance from the newest databases are used."
                        "If file ends in .mod, its assumes to be a phastCons model file, otherwise a newick tree file ")
    parser.add_argument("hgCentralDb",
                        help="""name of hgcentral database used to find active assemblies""")
    parser.add_argument("transMapGenomeDb",
                        help="""sqlite3 database for genome information""")
    opts = parser.parse_args()
    global verbose
    verbose = opts.verbose
    return opts


def getActiveHgDbs(hgCentralDb):
    sql = "SELECT name FROM dbDb WHERE active=1"
    hgCentralDbConn = hgDb.connect(hgCentralDb, dictCursor=True)
    cur = hgCentralDbConn.cursor()
    try:
        cur.execute(sql)
        return [row["name"] for row in cur]
    finally:
        cur.close()
        hgCentralDbConn.close()


def checkChainsDist(chains):
    "verify chains distance, report all errors"
    errCnt = 0
    for chain in chains:
        if chain.dist is None:
            sys.stderr.write("Error: no distance for {}".format(chain))
            errCnt += 1
    if errCnt != 0:
        raise Exception("{} chains without phylogenetic distance, add appropriate trees\n".format(errCnt))


def loadGenomicChains(transMapGenomeDbConn, distances, activeHgDbs):
    chainsFinder = ChainsFinder(distances)
    chains = chainsFinder.findChains(activeHgDbs)
    checkChainsDist(chains)
    chainsTbl = ChainsTbl(transMapGenomeDbConn, GenomesDbTables.chainsTbl, True)
    chainsTbl.loads(chains)
    chainsTbl.index()


def getGenomeInfo(hgCentralDb, transMapGenomeDb, trees, subsetHgDbs=None):
    distances = PhyloDistances(trees)
    transMapGenomeDbConn = sqlite3.connect(transMapGenomeDb)
    activeHgDbs = subsetHgDbs if subsetHgDbs is not None else getActiveHgDbs(hgCentralDb)
    loadGenomicChains(transMapGenomeDbConn, distances, activeHgDbs)
    transMapGenomeDbConn.close()

# entry
opts = parseArgs()
getGenomeInfo(opts.hgCentralDb, opts.transMapGenomeDb, opts.trees, opts.hgDbs)
