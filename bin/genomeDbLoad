#!/usr/bin/env python

import transMapProgSetup  # noqa: F401
import sys
import argparse
import sqlite3
# from transMap.genomeData import AnnotationType
from pycbio.hgdata import hgDb
from transMap.genomeData import GenomesDbTables, ChainsDbTable, GenomeAsm, GenomeAsmsDbTable, AnnotationType, AnnotationTypeSet
from transMap.ensembl import haveEnsemblFull, haveGencode
from transMap.chainsFinder import ChainsFinder
from transMap.phyloTrees import PhyloDistances
from transMap.genbankConf import GenbankConf


verbose = False


def parseArgs():
    desc = """Get information about genomes.  This finds all available chains and
    source data for all active genomes.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--verbose", action="store_true", default=False,
                        help="""verbose tracing""")
    parser.add_argument("--hgDb", action="append", default=None, dest="hgDbs",
                        help="""limit to these databases for testing, maybe repeated""")
    parser.add_argument("--tree", dest="trees", action="append", default=[],
                        help="set branch lengths from this tree file, maybe repeated.  The distance from the newest databases are used."
                        "If file ends in .mod, its assumes to be a phastCons model file, otherwise a newick tree file ")
    parser.add_argument("--genbankConfRa", default=GenbankConf.stdConfRaFile,
                        help="""UCSC genbank configuration ra file""")
    parser.add_argument("hgCentralDb",
                        help="""name of hgcentral database used to find active assemblies""")
    parser.add_argument("transMapGenomeDb",
                        help="""sqlite3 database for genome information""")
    opts = parser.parse_args()
    global verbose
    verbose = opts.verbose
    return opts


def getActiveDbDb(hgDbConn, hgCentralDb, subsetHgDbs=None):
    "returns rows from hgcentral dbDb"
    sql = "SELECT DISTINCT dd.name as name, dd.genome as genome, dd.organism as commonName, dd.scientificName as scientificName, gc.clade from {hgCentralDb}.dbDb dd, {hgCentralDb}.genomeClade gc WHERE (dd.genome = gc.genome)".format(hgCentralDb=hgCentralDb)
    if subsetHgDbs is not None:
        sql += " AND (name in ({}))".format(",".join(['"{}"'.format(db) for db in subsetHgDbs]))
    cur = hgDbConn.cursor()
    try:
        cur.execute(sql)
        return [row for row in cur]
    finally:
        cur.close()

def getAnnotationTypes(hgDbConn, hgDb, genbankConf):
    annTypes = set()
    gbDbConf = genbankConf.get(hgDb)
    if gbDbConf is not None:
        annTypes |= gbDbConf.getEnabled()
    if haveGencode(hgDbConn, hgDb):
        annTypes.add(AnnotationType.gencode)
    elif haveEnsemblFull(hgDbConn, hgDb):
        annTypes.add(AnnotationType.ensembl)
    if len(annTypes) == 0:
        return None
    else:
        return AnnotationTypeSet(annTypes)

def mkGenomeAsm(hgDbConn, dbDb, genbankConf):
    return GenomeAsm(dbDb["name"], dbDb["clade"], dbDb["commonName"], dbDb["scientificName"],
                     getAnnotationTypes(hgDbConn, dbDb["name"], genbankConf))

def loadGenomeAsms(transMapGenomeDbConn, hgDbConn, activeDbDbs, genbankConf):
    genomeAsms = [mkGenomeAsm(hgDbConn, dbDb, genbankConf) for dbDb in activeDbDbs]
    asmsTbl = GenomeAsmsDbTable(transMapGenomeDbConn, GenomesDbTables.genomeAsmsTbl, create=True)
    asmsTbl.loads(genomeAsms)

def checkChainsDist(chains):
    "verify chains distance, report all errors"
    errCnt = 0
    for chain in chains:
        if chain.dist is None:
            sys.stderr.write("Error: no distance for {}".format(chain))
            errCnt += 1
    if errCnt != 0:
        raise Exception("{} chains without phylogenetic distance, add appropriate trees\n".format(errCnt))


def loadGenomicChains(transMapGenomeDbConn, distances, activeHgDbs):
    chainsFinder = ChainsFinder(distances)
    chains = chainsFinder.findChains(activeHgDbs)
    checkChainsDist(chains)
    chainsTbl = ChainsDbTable(transMapGenomeDbConn, GenomesDbTables.chainsTbl, True)
    chainsTbl.loads(chains)
    chainsTbl.index()


def genomeDbLoad(hgCentralDb, transMapGenomeDb, trees, genbankConfRa, subsetHgDbs=None):
    genbankConf = GenbankConf(genbankConfRa)
    distances = PhyloDistances(trees)
    hgDbConn = hgDb.connect(dictCursor=True)
    transMapGenomeDbConn = sqlite3.connect(transMapGenomeDb)
    activeDbDbs = getActiveDbDb(hgDbConn, hgCentralDb, subsetHgDbs)
    activeHgDbs = [row["name"] for row in activeDbDbs]
    loadGenomeAsms(transMapGenomeDbConn, hgDbConn, activeDbDbs, genbankConf)
    loadGenomicChains(transMapGenomeDbConn, distances, activeHgDbs)
    transMapGenomeDbConn.close()
    hgDbConn.close()

# entry
opts = parseArgs()
genomeDbLoad(opts.hgCentralDb, opts.transMapGenomeDb, opts.trees, opts.genbankConfRa, opts.hgDbs)
