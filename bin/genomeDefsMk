#!/usr/bin/env python

import sys, os, string, cPickle
rootDir = os.path.normpath(os.path.dirname(os.path.realpath(sys.argv[0])) + "/..")
sys.path = [rootDir + "/extern/pycbio/lib", rootDir + "/lib/py"] + sys.path
from optparse import OptionParser
import glob,re
from pycbio.sys.fileOps import prRowv
from pycbio.sys import setOps, fileOps, dbOps
from pycbio.hgdata import hgDb
from transMap.genomeDefs import GenomeDefs,GenomeDb,AnnotationSet,Chains,ChainsSet
from transMap import phyloTreeOps,genbank

class CmdOpts(object):
    usage = """%prog [options] pickleOut
    Combine data from dbDb database on hgwdev, with Genbank track information from
    /hive/data/outside/genbank/etc/genbank.conf to build a pickled version of transMap.GenomeDefs.
     """

    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--includeClade", dest="includeClades", action="append", default=None,
                          help="include only specified clades (maybe repeated)")
        parser.add_option("--excludeClade", dest="excludeClades", action="append", default=None,
                          help="exclude specified clades (maybe repeated)")
        parser.add_option("--excludeDb", dest="excludeDbs", action="append", default=None,
                          help="exclude specified databases (maybe repeated)")
        parser.add_option("--debug", dest="debug", action="store_true", default=False,
                          help="print debugging information")
        parser.add_option("--tree", dest="trees", action="append", default=[],
                          help="set branch lengths from this tree file, maybe repeated.  The distance from the newest databases are used."
                          "If file ends in .mod, its assumes to be a phastCons model file, otherwise a newick tree file ")
        parser.add_option("--genomeInfo", dest="genomeInfo", action="store", default=None,
                          help="write information about all genomes found to this TSV file")
        parser.add_option("--chainInfo", dest="chainInfo", action="store", default=None,
                          help="write information about all chains found to this TSV file,  Only includes potential mappings ")
        parser.add_option("--distInfo", dest="distInfo", action="store", default=None,
                          help="write distance table")
        parser.add_option("--centralDb", dest="centralDb", action="store", default="hgcentraltest",
                          help="hgcentral database to use")
        (opts, args) = parser.parse_args()
        if len(args) != 1:
            parser.error("wrong number of arguments")
        (self.pickleOut,) = args
        self.__dict__.update(opts.__dict__)
        if self.includeClades != None:
            self.includeClades = frozenset(self.includeClades)
        if self.excludeClades != None:
            self.excludeClades = frozenset(self.excludeClades)

class GenomeDbReader(object):
    """object to read dbDb and genomeClade tables, doing some gross filtering"""

    class Rec(object):
        def __init__(self, dbName, clade, commonName, scientificName):
            self.dbName = dbName
            self.clade = clade
            self.commonName = commonName
            self.scientificName = scientificName

    def __init__(self, opts):
        self.centralDb = opts.centralDb
        self.includeClades = opts.includeClades
        self.excludeClades = opts.excludeClades
        self.excludeDbs = opts.excludeDbs

    def read(self):
        sql = "select distinct dd.name as db, dd.genome as genome, dd.organism as commonName, dd.scientificName as scientificName, gc.clade from dbDb dd, genomeClade gc where dd.genome=gc.genome"
        conn = hgDb.connect(self.centralDb, dictCursor=True)
        try:
            for row in dbOps.queryConnection(conn, sql):
                if self.__inclDb(row):
                    self.__checkDb(row)
                    yield self.Rec(row["db"], row["clade"], row["commonName"], row["scientificName"])
        finally:
            conn.close()

    def __checkDb(self, row):
        "sanity checks on assumptions in database"
        if row["genome"].lower() != row["commonName"].lower():
            raise Exception("assumption that dbDb.genome = dbDb.organism violated: " + str(row))

    def __inclDb(self, row):
        if not GenomeDb.dbParseRe.match(row["db"]):
            return False  # weirdly named genomes
        elif (self.includeClades != None) and (row["clade"] not in self.includeClades):
            return False  # clade not included
        elif (self.excludeClades != None) and (row["clade"] in self.excludeClades):
            return False # clade excluded
        elif (self.excludeDbs != None) and (row["db"] in self.excludeDbs):
            return False # db excluded
        else:
            return True

class CDnaInfoTbl(dict):
    """table of db to set of AnnotationSet, table from genbank.conf and alignments
    on file systems.  Also fill in ucscGenes and ensembl"""

    def __init__(self):
        "build from genbank.conf"
        self.refSeqAlnDir = self.__newestAlnSrcDbDir("refseq")
        self.genBankAlnDir = self.__newestAlnSrcDbDir("genbank")

        for genbankConf in genbank.GenbankConfTbl().itervalues():
            self[genbankConf.db] = self.__getSrcSet(genbankConf.db, genbankConf)

    def dump(self, fh):
        prRowv(fh, "CDnaInfoTbl")
        for db in self.iterkeys():
            prRowv(fh, "", db, setOps.setJoin(self[db]))

    empty = frozenset()
    def obtain(self, db):
        "get set of db, or an empty set if not found"
        annotationSets = self.get(db)
        if annotationSets == None:
            annotationSets = self.empty
        return annotationSets

    def __newestAlnSrcDbDir(self, srcDb):
        pat = "/hive/data/outside/genbank/data/aligned/" + srcDb + ".*"
        dirs = glob.glob(pat)
        if len(dirs) == 0:
            raise Exception("no directories matching: " + pat)
        dirs.sort()
        return dirs[len(dirs)-1]

    def __isGenbankAligned(self, db, annotationSet):
        if annotationSet == AnnotationSet.refSeq:
            pat = self.refSeqAlnDir + "/" + db + "/*/mrna.native.psl.gz"
        elif annotationSet == AnnotationSet.mrna:
            pat = self.genBankAlnDir + "/" + db + "/*/mrna.native.psl.gz"
        elif annotationSet == AnnotationSet.splicedEst:
            pat = self.genBankAlnDir + "/" + db + "/*/est.*.native.intronPsl.gz"
        return len(glob.glob(pat)) > 0

    def __haveTableLike(self, db, pat):
        conn = hgDb.connect(db)
        try:
            return dbOps.haveTableLike(conn, pat)
        finally:
            conn.close()

    def __isEnsemblProjectionBuild(self, db):
        "does this ensembl appear to be a projection (full or mixed) gene build?"
        # this is determined by there being at least one transcript that is mapped multiple times
        conn = hgDb.connect(db)
        try:
            sql = "select count(*) from (select name, count(*) as cnt from ensGene group by name) as counts where counts.cnt > 2";
            rows = list(dbOps.queryConnection(conn, sql))
            return (rows[0][0] > 0)
        finally:
            conn.close()
        
    def __hasEnsembl(self, db):
        "has gencode or ensembl?"
        return self.__haveTableLike(db, "wgEncodeGencodeComp%") or (self.__haveTableLike(db, "ensGene") and not self.__isEnsemblProjectionBuild(db))

    def __getSrcSet(self, db, genbankConf):
        "return set of AnnotationSet configured and aligned for db"
        aligned = set()
        for annotationSet in genbankConf.getEnabled():
            if self.__isGenbankAligned(db, annotationSet):
                aligned.add(annotationSet)
        if self.__haveTableLike(db, "knownGene"):
            aligned.add(AnnotationSet.ucscGenes)
        if self.__hasEnsembl(db):
            aligned.add(AnnotationSet.ensembl)
        return frozenset(aligned)

class DistTbl(object):
    """Distances between organisms.  Since the trees specify distances by
    assemble, we attempt to use the newest pair of assembles to define the
    distance.  There is no order and both directions are checked. """

    class Entry(object):
        def __init__(self, db1, db2, dist):
            self.org1 = db1.org  # objects
            self.db1 = db1  # updated when newer definition is found
            self.org2 = db2.org
            self.db2 = db2
            self.dist = dist

        def __sameOrgOrder(self, db1, db2):
            "check if this is the right order"
            return (db1.org == self.org1) and (db2.org == self.org2)

        def __isNewerDb(self, db1, db2):
            return (db1.dbNum >= self.db1.dbNum) and (db2.dbNum >= self.db2.dbNum)

        def __update(self, db1, db2, dist):
            self.db1 = db1
            self.db2 = db2
            self.dist = dist

        def updateIfNewer(self, dbA,  dbB, dist):
            """one must be the same and the other greater, or both greater to
            be considered newer (but not bother checking for both the same)"""
            if self.__sameOrgOrder(dbA, dbB):
                if self.__isNewerDb(dbA, dbB):
                    self.__update(dbA, dbB, dist)
            elif self.__sameOrgOrder(dbB, dbA):
                if self.__isNewerDb(dbB, dbA):
                    self.__update(dbB, dbA, dist)
            else:
                raise Exception("updateIfNewer mismatch")

    def __init__(self, defs):
        self.orgPairs = dict()  # indexed by Organism pair frozenset
        self.defs = defs

    def loadTrees(self, treeFiles):
        for treeFile in treeFiles:
            self.loadTree(treeFile)

    def loadTree(self, treeFile):
        tree = phyloTreeOps.load(treeFile)
        leafs = [tree.node(i) for i in tree.get_terminals()]
        for l1 in leafs:
            for l2 in leafs:
                if l1 != l2:
                    self.__addDbNamePair(l1.data.taxon, l2.data.taxon, tree.distance(l1.id, l2.id))

    def __addDbNamePair(self, dbName1, dbName2, dist):
        db1 = self.defs.getDbByName(dbName1)
        db2 = self.defs.getDbByName(dbName2)
        if (db1 != None) and (db2 != None):
            self.__addDbPair(db1, db2, dist)

    def __addDbPair(self, db1, db2, dist):
        key = frozenset((db1.org, db2.org))
        ent = self.orgPairs.get(key)
        if ent == None:
            self.orgPairs[key] = DistTbl.Entry(db1, db2, dist)
        else:
            ent.updateIfNewer(db1, db2, dist)

    def getByDb(self, db1, db2):
        "get distance by genome db pair, or None if not available"
        ent = self.orgPairs.get(frozenset((db1.org, db2.org)))
        if ent == None:
            return None
        else:
            return ent.dist

    def writeTsv(self, fh):
        fileOps.prRowv(fh, "org1", "db1", "org2", "db2", "dist")
        for op in self.orgPairs.itervalues():
            fileOps.prRowv(fh, op.org1.commonName, op.db1.name, op.org2.commonName, op.db2.name, op.dist)

class GenomeDefsMk(object):
    "build GenomeDefs object"
    def __init__(self, opts):
        self.includeClades = opts.includeClades
        self.excludeClades = opts.excludeClades,
        self.excludedDbs = opts.excludeDbs
        self.cdnaInfoTbl = CDnaInfoTbl()
        self.defs = GenomeDefs()

        for dbInfo in GenomeDbReader(opts).read():
            self.__addDb(dbInfo)
        self.defs.buildChainSets()
        self.defs.finish()

        self.distTbl = DistTbl(self.defs)
        self.distTbl.loadTrees(opts.trees)
        self.__setDistances(self.distTbl)

    def __addDb(self, dbInfo):
        self.defs.addGenomeDb(dbInfo.dbName, dbInfo.clade, dbInfo.commonName, dbInfo.scientificName,
                              self.cdnaInfoTbl.obtain(dbInfo.dbName))

    def __setChainsSetDist(self, distTbl, chset):
        dist = distTbl.getByDb(chset.srcDb, chset.destDb)
        if dist != None:
            chset.setDistance(dist)
        else:
            sys.stderr.write("Warning: no distance for: " + chset.srcDb.name + "<>" + chset.destDb.name+"\n")
        
    def __setDistances(self, distTbl):
        for srcDb in self.defs.dbs.itervalues():
            for chset in srcDb.destChainsSets.itervalues():
                self.__setChainsSetDist(distTbl, chset)

    def __getCdnaTypeDesc(self, annotationSets):
        if annotationSets != None:
            return setOps.setJoin(annotationSets,",")
        else:
            return ""

    def writeGenomeInfo(self, fh):
        fileOps.prRowv(fh, "db", "clade", "commonName", "scientificName", "annotationSets")
        for orgName in sorted(self.defs.orgs.iterkeys()):
            for db in sorted(self.defs.orgs[orgName].dbs):
                fileOps.prRowv(fh, db.name, db.clade, db.commonName, db.scientificName, self.__getCdnaTypeDesc(db.annotationSets))

    def writeChains(self, fh):
        fileOps.prRowv(fh, "srcDb", "destDb", "dist", "chainTypes", "srcClade", "destClade")
        for srcDb in self.defs.dbs.itervalues():
            for chset in srcDb.destChainsSets.itervalues():
                fileOps.prRowv(fh, chset.srcDb.name, chset.destDb.name, chset.dist, chset.getTypesStr(), chset.srcDb.clade, chset.destDb.clade)
        
    def dump(self, fh):
        self.cdnaInfoTbl.dump(fh)
        self.defs.dump(fh)


opts = CmdOpts()
gdmk = GenomeDefsMk(opts)

if opts.debug:
    gdmk.dump(sys.stderr)

if opts.genomeInfo != None:
    with open(opts.genomeInfo, "w") as fh:
        gdmk.writeGenomeInfo(fh)
if opts.chainInfo != None:
    with open(opts.chainInfo, "w") as fh:
        gdmk.writeChains(fh)
if opts.distInfo != None:
    with open(opts.distInfo, "w") as fh:
        gdmk.distTbl.writeTsv(fh)

gdmk.defs.save(opts.pickleOut)
