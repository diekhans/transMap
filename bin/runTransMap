#!/usr/bin/env python

import sys, os
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.append(myBinDir + "/../extern/pycbio/lib")
sys.path.append(myBinDir + "/../lib/py")
execPath = myBinDir + "/../output/bin/" + os.uname()[4] + "/opt"
os.environ["PATH"] = execPath + ":" + myBinDir +":"+ os.environ["PATH"]

from optparse import OptionParser
from pycbio.sys import fileOps, Pipeline, procOps
from transMap import GenomeDefs, setTMPDIR, getTmpExt, runCmds
from transMap.GenomeDefs import ChainType
from transMap.TransMap import TransMap,Chroms

class CmdOpts(object):
    usage = """%prog [options] genomeDefsPickle srcDb destDb chainType cdnaType cdnaPart clusterDir mappedPsl"""
    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--chrom", dest="chroms", action="append", default=None,
                          help="only process this destination chrom, maybe repeated")
        parser.add_option("--firstChrom", dest="firstChrom", action="store", default=None,
                          help="destDb start destination chrom in reverse size sort list")
        parser.add_option("--lastChrom", dest="lastChrom", action="store", default=None,
                          help="destDb last destination chrom in reverse size sort list")
        (opts, args) = parser.parse_args()
        if len(args) != 8:
            parser.error("wrong number of arguments")
        (self.genomeDefsPickle, self.srcDb, self.destDb, self.chainType, self.cdnaType, self.cdnaPart, self.clusterDir, self.mappedPsl) = args
        self.__dict__.update(opts.__dict__)
        if ((opts.firstChrom != None) or (opts.lastChrom != None)) and ((opts.firstChrom == None) or (opts.lastChrom == None)):
            parser.error("must specified either both or neither of --firstChrom and --lastChrom")

    def fixEnums(self):
        # FIXME: don't convert Enumerations until GenomeDefs is loaded
        self.chainType = GenomeDefs.ChainType(self.chainType)
        self.cdnaType = GenomeDefs.CDnaType(self.cdnaType)

def bldChroms(opts, dest2bit):
    chromSet = None
    if (opts.chroms != None) or (opts.firstChrom != None):
        chromSet = []
        if opts.chroms != None:
            chromSet.extend(opts.chroms)
        if (opts.firstChrom != None):
            chroms = Chroms(dest2Bit)
            chromSet.extend(chroms.getRange(opts.firstChrom, opts.lastChrom))
    return chromSet

# memory optimizations:
#   - limit cDNA fasta sequences read by pslRecalcMatch step to those that aligned
#   - limit chains read by netChainSubset, since it reads all chains into memory

opts = CmdOpts()
tmpDir = setTMPDIR()
tmpExt = getTmpExt()

# skip if already completed
if os.path.exists(opts.mappedPsl):
    sys.stderr.write("Note: output already exists, skipping: " + opts.mappedPsl + "\n")
    sys.exit(0)

genomeDefs = GenomeDefs.load(opts.genomeDefsPickle)
opts.fixEnums()
transMap = TransMap(None, genomeDefs, ".", None, opts.clusterDir)
srcDb = genomeDefs.dbs[opts.srcDb]
destDb = genomeDefs.dbs[opts.destDb]

rel2bit =  destDb.name + "/" + destDb.name + ".2bit"
dest2Bit = "/scratch/data/" + rel2bit
if not os.path.exists(dest2Bit):
    if isParasol:
        raise Exception("on cluster and local 2bit not found: " + dest2Bit)
    dest2Bit = "/cluster/data/" + rel2bit
if (opts.chroms != None) or (opts.firstChrom != None):
    chroms = bldChroms(opts, dest2Bit)
else:
    chroms = None

##
# input
##

# chains
chainsSet = srcDb.destChainsSets.getChainsSet(destDb)

# cDNA
srcPsl = transMap.getClusterSrcPsl(srcDb, opts.cdnaType, opts.cdnaPart)
srcFa = transMap.getClusterSrcFa(srcDb, opts.cdnaType, opts.cdnaPart)

# genome sequence
relTargetSeq = "data/" + destDb.name + "/" + destDb.name + ".2bit"
targetSeq = "/scratch/" + relTargetSeq
if not os.path.exists(targetSeq):
    if isParasol:
        raise Exception("on cluster, can't find local genome: " + targetSeq)
    targetSeq = "/cluster/" + relTargetSeq
if not os.path.exists(targetSeq):
    raise Exception("can't find genome: " + targetSeq)


##
# intermediate output
##
rawPslTmp = tmpDir + "/mapped.psl" + tmpExt
chainSubsetTmp = tmpDir + "/mapping.chain" + tmpExt
mapInfoRawTmp = tmpDir+ "/mapped.mapinfo.raw" + tmpExt

# output
outPrefix = os.path.splitext(fileOps.uncompressedBase(opts.mappedPsl))[0]
outPslTmp = opts.mappedPsl + tmpExt
outMapInfo = outPrefix + ".mapinfo"

###
# Get the chains to use.   Pre-filter with overlapSelect to reduce
# memory requirements of pslMap and netChainSubset.
###
chains = chainsSet.getSupportingType(opts.chainType)
preFiltCmds = []

preFiltCmds.append(["overlapSelect", "-inFmt=chainq", srcPsl, chains.chainFile, "/dev/stdout"])
if chroms != None:
    preFiltCmds.append(["chainFilter", "-noHap", "-t=" + ",".join(chroms), "/dev/stdin"])
else:
    preFiltCmds.append(["chainFilter", "-noHap", "stdin"])

runCmds(preFiltCmds, stdout=chainSubsetTmp)

chainFilterCmds = []
if (opts.chainType == ChainType.all) or (opts.chainType == ChainType.rbest):
    # no filtering
    chainInFileRef = chainSubsetTmp
else:
    # syn filtering
    chainFilterCmds.append(["netFilter", "-syn", "-noHap", chains.netFile])
    chainFilterCmds.append(["netChainSubset", "-wholeChains", "-skipMissing", "-verbose=0", "/dev/stdin", chainSubsetTmp, "/dev/stdout"])
    chainInFileRef = "/dev/stdin"

###
# map alignments.  Pre-filter before pslRecalcMatch to avoid it take hours when there are huge
# number of mappings (say > 50,000 for one refseq in mapped to monDom5)
##
pslMap = ["pslMap", "-chainMapFile", "-mapInfo="+mapInfoRawTmp, srcPsl, chainInFileRef, "/dev/stdout"]
qsort = ["sort","-k","10,10", "-k", "12,12n", "-k", "13,13n"]

pslCDnaFilter = ["pslCDnaFilter", "-verbose=0", "-minQSize=" + str(transMap.minQSize), "-minCover=" + str(transMap.minCover),
                 "-globalNearBest=" + str(transMap.getGlobalNearBestPreFilter(destDb)), "stdin", "stdout"]

# target sort speeds up pslRecalcMatch
tsort = ["sort","-k","14,14", "-k", "16,16n"]
fileOps.ensureFileDir(opts.mappedPsl)
runCmds(chainFilterCmds + [pslMap, qsort, pslCDnaFilter, tsort], stdout=rawPslTmp)

###
# add type of chains to mapInfo, select subset of alignments
##
addMapInfoChainType = ["addMapInfoChainType", "-v", "chainType="+str(opts.chainType), mapInfoRawTmp]
pslMapInfoSelect = ["pslMapInfoSelect", "/dev/stdin", rawPslTmp, outMapInfo]
runCmds([addMapInfoChainType, pslMapInfoSelect])

###
# calculate match stats
##
pslRecalcMatch = ["pslRecalcMatch", "-ignoreQUniq", rawPslTmp, targetSeq,
                  transMap.getClusterSrcFa(srcDb, opts.cdnaType, opts.cdnaPart), "/dev/stdout"]

# qsort here, just to make filter qsort quicker
runCmds([pslRecalcMatch, qsort], stdout=outPslTmp)

os.rename(outPslTmp, opts.mappedPsl)

os.unlink(rawPslTmp)
os.unlink(chainSubsetTmp)
os.unlink(mapInfoRawTmp)
