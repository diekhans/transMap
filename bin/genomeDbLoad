#!/usr/bin/env python

import transMapProgSetup  # noqa: F401
import sys
import argparse
import sqlite3
from pycbio.sys import loggingOps
from pycbio.sys import fileOps
from pycbio.hgdata import hgDb
from transMap import hgDbNameCheck
from transMap.transMapConf import transMapConfLoad
from transMap.genomeData import GenomesDbTables, ChainsDbTable, GenomeAsm, GenomeAsmsDbTable, AnnotationType, AnnotationTypeSet
from transMap.ensembl import haveEnsemblFull, haveGencode
from transMap.chainsFinder import ChainsFinder
from transMap.phyloTrees import PhyloDistances
from transMap.genbankConf import GenbankConf


def parseArgs():
    desc = """Get information about genomes.  This finds all available chains and
    source data for all active genomes.
    """
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument("--hgDb", action="append", default=None, dest="subsetHgDbs",
                        help="""limit to these databases for testing, maybe repeated""")
    parser.add_argument("configPyFile",
                        help="""configuration python file""")
    parser.add_argument("hgCentralDb",
                        help="""name of hgcentral database used to find active assemblies""")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    return opts


def getActiveDbDb(hgDbConn, hgCentralDb, subsetHgDbs=None):
    "returns rows from hgcentral dbDb"
    sql = "SELECT DISTINCT dd.name as name, dd.genome as genome, dd.organism as commonName, dd.scientificName as scientificName, gc.clade FROM {hgCentralDb}.dbDb dd, {hgCentralDb}.genomeClade gc WHERE (dd.active = 1) AND (dd.genome = gc.genome) ".format(hgCentralDb=hgCentralDb)
    if subsetHgDbs is not None:
        sql += " AND (name in ({}))".format(",".join(['"{}"'.format(db) for db in subsetHgDbs]))
    cur = hgDbConn.cursor()
    try:
        cur.execute(sql)
        return [row for row in cur if hgDbNameCheck(row["name"])]
    finally:
        cur.close()


def getAnnotationTypes(hgDbConn, hgDb, genbankConf):
    annTypes = set()
    gbDbConf = genbankConf.get(hgDb)
    if gbDbConf is not None:
        annTypes |= gbDbConf.getEnabled()
    if haveGencode(hgDbConn, hgDb):
        annTypes.add(AnnotationType.gencode)
    elif haveEnsemblFull(hgDbConn, hgDb):
        annTypes.add(AnnotationType.ensembl)
    if len(annTypes) == 0:
        return None
    else:
        return AnnotationTypeSet(annTypes)


def mkGenomeAsm(hgDbConn, dbDb, genbankConf):
    return GenomeAsm(dbDb["name"], dbDb["clade"], dbDb["commonName"], dbDb["scientificName"],
                     getAnnotationTypes(hgDbConn, dbDb["name"], genbankConf))


def loadGenomeAsms(genomeDbConn, hgDbConn, activeDbDbs, genbankConf):
    genomeAsms = [mkGenomeAsm(hgDbConn, dbDb, genbankConf) for dbDb in activeDbDbs]
    asmsTbl = GenomeAsmsDbTable(genomeDbConn, GenomesDbTables.genomeAsmsTbl, create=True)
    asmsTbl.loads(genomeAsms)
    asmsTbl.index()


def checkChainsDist(chains):
    "verify chains distance, report all errors"
    errCnt = 0
    for chain in chains:
        if chain.dist is None:
            sys.stderr.write("Error: no distance for {}".format(chain))
            errCnt += 1
    if errCnt != 0:
        raise Exception("{} chains without phylogenetic distance, add appropriate trees\n".format(errCnt))


def loadGenomicChains(genomeDbConn, distances, activeHgDbs):
    chainsFinder = ChainsFinder(distances)
    chains = chainsFinder.findChains(activeHgDbs)
    checkChainsDist(chains)
    chainsTbl = ChainsDbTable(genomeDbConn, GenomesDbTables.chainsTbl, True)
    chainsTbl.loads(chains)
    chainsTbl.index()


def genomeDbLoad(opts):
    conf = transMapConfLoad(opts.configPyFile)
    genbankConf = GenbankConf(conf.genbankConfRa)
    distances = PhyloDistances(conf.treeFiles)
    hgDbConn = hgDb.connect(dictCursor=True)
    genomeDbTmp = fileOps.atomicTmpFile(conf.genomeDb)
    fileOps.ensureFileDir(conf.genomeDb)
    genomeDbConn = sqlite3.connect(genomeDbTmp)
    activeDbDbs = getActiveDbDb(hgDbConn, opts.hgCentralDb, opts.subsetHgDbs)
    activeHgDbs = [row["name"] for row in activeDbDbs]
    print activeHgDbs
    assert False
    loadGenomeAsms(genomeDbConn, hgDbConn, activeDbDbs, genbankConf)
    loadGenomicChains(genomeDbConn, distances, activeHgDbs)
    genomeDbConn.close()
    fileOps.atomicInstall(genomeDbTmp, conf.genomeDb)
    hgDbConn.close()

# entry
genomeDbLoad(parseArgs())
