#!/usr/bin/env python

import sys, os, string, cPickle
rootDir = os.path.normpath(os.path.dirname(os.path.realpath(sys.argv[0])) + "/..")
sys.path = [rootDir + "/extern/pycbio/lib", rootDir + "/lib/py"] + sys.path
from optparse import OptionParser
import glob,re
from pycbio.sys.fileOps import prRowv
from pycbio.sys import setOps, fileOps
from pycbio.sys.Pipeline import Pipeline
from pycbio.tsv.TSVReader import TSVReader
from transMap.GenomeDefs import GenomeDefs,GenomeDb,CDnaType,Chains,ChainsSet
from Bio.Nexus import Trees

# ucscGenes  containing srcDbs FIXME: automate
ucscGenesDbs = frozenset(("hg18", "mm9"))


class CmdOpts(object):
    usage = """%prog [options] pickleOut
    Combine data from dbDb database on hgwdev, with Genbank track information from
    /cluster/data/genbank/etc/genbank.conf to build a pickled version of transMap.GenomeDefs.
     """

    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--includeClade", dest="includeClades", action="append", default=None,
                          help="include only specified clades (maybe repeated)")
        parser.add_option("--excludeClade", dest="excludeClades", action="append", default=None,
                          help="exclude specified clades (maybe repeated)")
        parser.add_option("--excludeDb", dest="excludeDbs", action="append", default=None,
                          help="exclude specified databases (maybe repeated)")
        parser.add_option("--debug", dest="debug", action="store_true", default=False,
                          help="print debugging information")
        parser.add_option("--tree", dest="trees", action="append", default=[],
                          help="set branch lengths from this tree file, maybe repeated.  The distance from the newest databases are used."
                          "If file ends in .mod, its assumes to be a phastCons model file, otherwise a newick tree file ")
        parser.add_option("--info", dest="info", action="store", default=None,
                          help="write information about mappings to this file")
        parser.add_option("--chainDists", dest="chainDists", action="store", default=None,
                          help="write information chain distances to this file.  Only includes potential mappings ")
        (opts, args) = parser.parse_args()
        if len(args) != 1:
            parser.error("wrong number of arguments")
        (self.pickleOut,) = args
        self.__dict__.update(opts.__dict__)
        if self.includeClades != None:
            self.includeClades = set(self.includeClades)
        if self.excludeClades != None:
            self.excludeClades = set(self.excludeClades)

class GenomeDbReader(object):
    """object to build GenomeDb objects from dbDb and genomeClade tables, doing some gross filtering"""
    def __init__(self, opts):
        self.includeClades = opts.includeClades
        self.excludeClades = opts.excludeClades
        self.excludeDbs = opts.excludeDbs
        cmd = ["hgw-sql", "-e", "select dd.name as db, dd.organism as common, dd.scientificName as scientific, gc.clade from dbDb dd, genomeClade gc where dd.genome=gc.genome", "hgcentraltest"]
        self.pin = Pipeline(cmd, 'r')
        self.reader = TSVReader("<sqlquery>", inFh=self.pin)

    def __iter__(self):
        return self

    def next(self):
        for row in self.reader:
            if self.__inclDb(row, self.includeClades, self.excludeClades, self.excludeDbs):
                return GenomeDb(row.db, row.clade, row.common, row.scientific)
        raise StopIteration()

    def __inclDb(self, row, includeClades, excludeClades, excludeDbs):
        if not GenomeDb.dbParseRe.match(row.db):
            return False  # weirdly named genomes
        if includeClades and (row.clade not in includeClades):
            return False  # clade not included
        if (excludeClades != None) and (row.clade in excludeClades):
            return False # clade excluded
        if (excludeDbs != None) and (row.db in excludeDbs):
            return False # db excluded
        return True

class Conf(object):
    """configuration of genbank for a genome or the defaults.
    handles on/off/defaulted"""
    __slots__ = ("db", "on", "off")
    def __init__(self, db):
        self.db = db
        self.on = set()
        self.off = set()

    def __str__(self):
        return self.db + "\ton:" + setOps.setJoin(self.on,",") + "\toff:" + setOps.setJoin(self.off,",")

    def getEnabled(self, dflt):
        return frozenset(self.on | dflt.on.difference(self.off))

class CDnaInfoTbl(dict):
    """table of db to set of CDnaType, table from genbank.conf and alignments
    on file systems.  Also fill in ucscGenes"""

    def __init__(self):
        "build from genbank.conf"
        self.refSeqAlnDir = self.__newestAlnSrcDbDir("refseq")
        self.genBankAlnDir = self.__newestAlnSrcDbDir("genbank")

        confTbl = self.__loadGenbankConf()
        dflt = confTbl["default"]
        for conf in confTbl.itervalues():
            if conf != dflt:
                self[conf.db] = self.__getAlignedSet(conf.db, conf.getEnabled(dflt))

    def dump(self, fh):
        prRowv(fh, "CDnaInfoTbl")
        for db in self.iterkeys():
            prRowv(fh, "", db, setOps.setJoin(self[db]))

    empty = frozenset()
    def obtain(self, db):
        "get set of db, or an empty set if not found"
        cdnaTypes = self.get(db)
        if cdnaTypes == None:
            cdnaTypes = self.empty
        return cdnaTypes

    def __newestAlnSrcDbDir(self, srcDb):
        pat = "/cluster/data/genbank/data/aligned/" + srcDb + ".*"
        dirs = glob.glob(pat)
        if len(dirs) == 0:
            raise Exception("no directories matching: " + pat)
        dirs.sort()
        return dirs[len(dirs)-1]

    def __isAligned(self, db, cdnaType):
        if cdnaType == CDnaType.refSeq:
            pat = self.refSeqAlnDir + "/" + db + "/*/mrna.native.psl.gz"
        elif cdnaType == CDnaType.mrna:
            pat = self.genBankAlnDir + "/" + db + "/*/mrna.native.psl.gz"
        elif cdnaType == CDnaType.splicedEst:
            pat = self.genBankAlnDir + "/" + db + "/*/est.*.native.intronPsl.gz"
        return len(glob.glob(pat)) > 0
        
    def __getAlignedSet(self, db, enabled):
        "return set of CDnaType configured and aligned for db"
        # don't use panTro, as a source Db, as it has few of it's own,
        # and human being treated as native
        if db.startswith("panTro"):
            return frozenset()

        aligned = set()
        for cdnaType in enabled:
            if self.__isAligned(db, cdnaType):
                aligned.add(cdnaType)
        if db in ucscGenesDbs:
                aligned.add(CDnaType.ucscGenes)
        return frozenset(aligned)

    # parse clusterGenome line, used so we find entries that all all defaults
    parseGenomeRe = re.compile("^([A-Za-z0-9]+)\\.clusterGenome\s*=")

    # parse a cDNA line        1                2                  3                     4                  5
    parseCDnaRe = re.compile("^([A-Za-z0-9]+)\\.(genbank|refseq)\\.(mrna|est)\\.native\\.(load|align)\s*=\s*(yes|no)")

    def __loadGenbankConf(self):
        "build dict of Conf objects"
        confTbl = dict()
        for line in fileOps.iterLines("/cluster/data/genbank/etc/genbank.conf"):
            line = line.strip()
            parsed = self.parseGenomeRe.match(line)
            if parsed != None:
                self.__obtainConf(parsed.group(1), confTbl)
            parsed = self.parseCDnaRe.match(line)
            if parsed != None:
                self.__processConf(confTbl, parsed, line)
        return confTbl

    def __obtainConf(self, db, confTbl):
        "get a Conf entry, creating if it doesn't exist"
        conf = confTbl.get(db)
        if conf == None:
            conf = confTbl[db] = Conf(db)
        return conf
            
    def __processConf(self, confTbl, parsed, line):
        "add or update a Conf object given a parsed line"
        db = parsed.group(1)
        cdna = None
        if parsed.group(2) == "refseq":
            cdna = CDnaType.refSeq
        elif parsed.group(2) == "genbank":
            if parsed.group(3) == "mrna":
                cdna = CDnaType.mrna
            elif parsed.group(3) == "est":
                cdna = CDnaType.splicedEst
        state = None
        if parsed.group(5) == "yes":
            state = True
        elif parsed.group(5) == "no":
            state = False
        if (cdna == None) or (state == None):
            raise Exception("can't parse genbank.conf line: "+line)
        conf = self.__obtainConf(db, confTbl)
        if state:
            conf.on.add(cdna)
        else:
            conf.off.add(cdna)

class DistTbl(dict):
    """table indexed by frozenset(orgName1, orgName2) to Entry objects"""
    class Entry(object):
        def __init__(self, orgName1, orgNum1, orgName2, orgNum2, dist):
            self.orgName1 = orgName1
            self.orgNum1 = orgNum1
            self.orgName2 = orgName2
            self.orgNum2 = orgNum2
            self.dist = dist
    
        def __same(self, orgName1, orgName2):
            return (orgName1 == self.orgName1) and (orgName2 == self.orgName2)

        def __isNewer(self, orgNum1, orgNum2):
            """one must be the same and the other greater, or both greater to
            be considered newer (but not bother checking for both the same)"""
            return (orgNum1 >= self.orgNum1) and (orgNum2 >= self.orgNum2)

        def updateIfNewer(self, orgNameA, orgNumA, orgNameB, orgNumB, dist):
            if self.__same(orgNameA, orgNameB):
                if self.__isNewer(orgNumA, orgNumB):
                    self.dist = dist
            elif self.__same(orgNameB, orgNameA):
                if self.__isNewer(orgNumB, orgNumA):
                    self.dist = dist
            else:
                raise Exception("updateIfNewer mismatch")

    def __init__(self, treeFile):
        tree = self.__loadTree(treeFile)
        leafs = [tree.node(i) for i in tree.get_terminals()]
        for l1 in leafs:
            for l2 in leafs:
                if l1 != l2:
                    self.__addPair(l1.data.taxon, l2.data.taxon, tree.distance(l1.id, l2.id))

    def __parsePhastConsMod(self, treeFile):
        strtree = None
        for line in fileOps.iterLines(treeFile):
            if line.startswith("TREE:"):
                strtree = line[6:]
        if strtree == None:
            raise Exception("TREE: not found in phastCons model: " + treeFile)
        return strtree

    def __loadTree(self, treeFile):
        if treeFile.endswith(".mod"):
            strtree = self.__parsePhastConsMod(treeFile)
        else:
            strtree = "".join(fileOps.readFileLines(treeFile))
        return Trees.Tree(strtree)

    def __addPair(self, dbName1, dbName2, dist):
        orgName1, orgNum1 = GenomeDb.dbParse(dbName1)
        orgName2, orgNum2 = GenomeDb.dbParse(dbName2)
        key = frozenset((orgName1, orgName2))
        ent = self.get(key)
        if ent == None:
            self[key] = DistTbl.Entry(orgName1, orgNum1, orgName2, orgNum2, dist)
        else:
            ent.updateIfNewer(orgName1, orgNum1, orgName2, orgNum2, dist)

    def getByOrgDb(self, orgDbName1, orgDbName2):
        "get distance by genome db pair, or None if not available"
        ent = self.get(frozenset([orgDbName1, orgDbName2]))
        if ent == None:
            return None
        else:
            return ent.dist

class GenomeDefsMk(object):
    "build GenomeDefs object"
    def __init__(self, opts):
        self.includeClades = opts.includeClades
        self.excludeClades = opts.excludeClades,
        self.excludedDbs = opts.excludeDbs
        self.cdnaInfoTbl = CDnaInfoTbl()
        self.defs = GenomeDefs()

        for db in GenomeDbReader(opts):
            self.__addDb(db)
        self.defs.buildChainSets()
        self.defs.finish()
        for treeFile in opts.trees:
            self.__setDistances(treeFile)

    def __addDb(self, db):
        db.cdnaTypes = self.cdnaInfoTbl.obtain(db.name)
        self.defs.addGenomeDb(db)

    def __setDistances(self, treeFile):
        dists = DistTbl(treeFile)
        for chset in self.defs.chainsSets:
            if chset.dist == None:
                dist = dists.getByOrgDb(chset.srcDb.orgDbName, chset.destDb.orgDbName)
                if dist != None:
                    chset.setDistance(dist)

    def __buildOrgChainsSets(self, org):
        "build list of ChainsSets from an organisms"
        chsets = []
        doneDestOrgs = set()
        for srcDb in org.dbs:
            if len(srcDb.cdnaTypes) > 0:
                for chset in srcDb.destChainsSets.itervalues():
                    if chset.destDb.org  not in doneDestOrgs:
                        doneDestOrgs.add(chset.destDb.org)
                        chsets.append(chset)
        return chsets

    def writeDists(self, fh):
        chsets = []
        for org in self.defs.orgs.itervalues():
            chsets.extend(self.__buildOrgChainsSets(org))
        chsets.sort(ChainsSet.distCmp)
        for chset in chsets:
            fileOps.prRowv(fh, chset.srcDb.name, chset.destDb.name, chset.dist, chset.srcDb.clade, chset.destDb.clade)
        
    def dump(self, fh):
        self.cdnaInfoTbl.dump(fh)
        self.defs.dump(fh)


opts = CmdOpts()
gdmk = GenomeDefsMk(opts)

if opts.debug:
    gmk.dump(sys.stderr)

if opts.info != None:
    fh = open(opts.info, "w")
    gdmk.defs.dump(fh)
    fh.close()

if opts.chainDists != None:
    fh = open(opts.chainDists, "w")
    gdmk.writeDists(fh)
    fh.close()

gdmk.defs.save(opts.pickleOut)
