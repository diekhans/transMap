#!/usr/bin/env python

import sys, os, string, cPickle
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.append(myBinDir + "/../extern/pycbio/lib")
sys.path.append(myBinDir + "/../lib/py")
from optparse import OptionParser
import glob,re
from pycbio.sys.fileOps import prRowv
from pycbio.sys import setOps, fileOps
from pycbio.sys.Pipeline import Pipeline
from pycbio.tsv.TSVReader import TSVReader
from transMap.GenomeDefs import GenomeDefs,GenomeDb,CDnaTypes,Chains,ChainOrient

# ucscGenes  containing srcDbs FIXME: automate
ucscGenesDbs = frozenset(("hg18", "mm9"))


class CmdOpts(object):
    usage = """%prog [options] pickleOut
    Combine data from dbDb database on hgwdev, with Genbank track information from
    /cluster/data/genbank/etc/genbank.conf to build a pickled version of transMap.GenomeDefs.
     """

    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--includeClade", dest="includeClades", action="append", default=None,
                          help="include only specified clades (maybe repeated)")
        parser.add_option("--excludeClade", dest="excludeClades", action="append", default=None,
                          help="exclude specified clades (maybe repeated)")
        parser.add_option("--excludeDbs", dest="excludeDbs", action="append", default=None,
                          help="exclude specified databases (maybe repeated)")
        parser.add_option("--debug", dest="debug", action="store_true", default=False,
                          help="print debugging information")
        parser.add_option("--info", dest="info", action="store", default=None,
                          help="write information about mappints to info file")
        (opts, args) = parser.parse_args()
        if len(args) != 1:
            parser.error("wrong number of arguments")
        (self.pickleOut,) = args
        self.__dict__.update(opts.__dict__)
        if self.includeClades != None:
            self.includeClades = set(self.includeClades)
        if self.excludeClades != None:
            self.excludeClades = set(self.excludeClades)

class DbInfoTbl(dict):
    """table of GenomeDb objects build from dbDb and genomeClade, indexed by db.
    """

    def __init__(self, includeClades=None, excludeClades=None, excludeDbs=None):
        cmd = ["hgw-sql", "-e", "select dd.name as db, dd.organism as common, dd.scientificName as scientific, gc.clade from dbDb dd, genomeClade gc where dd.genome=gc.genome", "hgcentraltest"]
        pin = Pipeline(cmd, 'r')
        for row in TSVReader("<sqlquery>", inFh=pin):
            if self.__inclDb(row, includeClades, excludeClades, excludeDbs):
                self[row.db] = GenomeDb(row.db, row.clade)

    def __inclDb(self, row, includeClades, excludeClades, excludeDbs):
        if not GenomeDb.dbParseRe.match(row.db):
            return False  # weirdly named genomes
        if includeClades and (row.clade not in includeClades):
            return False  # clade not included
        if (excludeClades != None) and (row.clade in excludeClades):
            return False # clade excluded
        if (excludeDbs != None) and (row.db in includeClades):
            return False # db excluded
        return True

    def dump(self, fh):
        prRowv(fh, "DbInfoTbl")
        for di in self.itervalues():
            prRowv(fh, "", di)


class Conf(object):
    """configuration of genbank for a genome or the defaults.
    handles on/off/defaulted"""
    __slots__ = ("db", "on", "off")
    def __init__(self, db):
        self.db = db
        self.on = set()
        self.off = set()

    def __str__(self):
        return self.db + "\ton:" + setOps.setJoin(self.on,",") + "\toff:" + setOps.setJoin(self.off,",")

    def getEnabled(self, dflt):
        return frozenset(self.on | dflt.on.difference(self.off))

class CDnaInfoTbl(dict):
    """table of db to set of CDnaTypes, table from genbank.conf and alignments
    on file systems.  Also fill in ucscGenes"""

    def __init__(self):
        "build from genbank.conf"
        self.refSeqAlnDir = self.__newestAlnSrcDbDir("refseq")
        self.genBankAlnDir = self.__newestAlnSrcDbDir("genbank")

        confTbl = self.__loadGenbankConf()
        dflt = confTbl["default"]
        for conf in confTbl.itervalues():
            if conf != dflt:
                self[conf.db] = self.__getAlignedSet(conf.db, conf.getEnabled(dflt))

    def dump(self, fh):
        prRowv(fh, "CDnaInfoTbl")
        for db in self.iterkeys():
            prRowv(fh, "", db, setOps.setJoin(self[db]))

    def __newestAlnSrcDbDir(self, srcDb):
        pat = "/cluster/data/genbank/data/aligned/" + srcDb + ".*"
        dirs = glob.glob(pat)
        if len(dirs) == 0:
            raise Exception("no directories matching: " + pat)
        dirs.sort()
        return dirs[len(dirs)-1]

    def __isAligned(self, db, cdnaType):
        if cdnaType == CDnaTypes.refSeq:
            pat = self.refSeqAlnDir + "/" + db + "/*/mrna.native.psl.gz"
        elif cdnaType == CDnaTypes.mrna:
            pat = self.genBankAlnDir + "/" + db + "/*/mrna.native.psl.gz"
        elif cdnaType == CDnaTypes.splicedEst:
            pat = self.genBankAlnDir + "/" + db + "/*/est.*.native.intronPsl.gz"
        return len(glob.glob(pat)) > 0
        
    def __getAlignedSet(self, db, enabled):
        "return set of CDnaTypes configured and aligned for db"
        # don't use panTro, as a source Db, as it has few of it's own,
        # and human being treated as native
        if db.startswith("panTro"):
            return frozenset()

        aligned = set()
        for cdnaType in enabled:
            if self.__isAligned(db, cdnaType):
                aligned.add(cdnaType)
        if db in ucscGenesDbs:
                aligned.add(CDnaTypes.ucscGenes)
        return frozenset(aligned)

    # parse clusterGenome line, used so we find entries that all all defaults
    parseGenomeRe = re.compile("^([A-Za-z0-9]+)\\.clusterGenome\s*=")

    # parse a cDNA line        1                2                  3                     4                  5
    parseCDnaRe = re.compile("^([A-Za-z0-9]+)\\.(genbank|refseq)\\.(mrna|est)\\.native\\.(load|align)\s*=\s*(yes|no)")

    def __loadGenbankConf(self):
        "build dict of Conf objects"
        confTbl = dict()
        for line in fileOps.iterLines("/cluster/data/genbank/etc/genbank.conf"):
            line = line.strip()
            parsed = self.parseGenomeRe.match(line)
            if parsed != None:
                self.__obtainConf(parsed.group(1), confTbl)
            parsed = self.parseCDnaRe.match(line)
            if parsed != None:
                self.__processConf(confTbl, parsed, line)
        return confTbl

    def __obtainConf(self, db, confTbl):
        "get a Conf entry, creating if it doesn't exist"
        conf = confTbl.get(db)
        if conf == None:
            conf = confTbl[db] = Conf(db)
        return conf
            
    def __processConf(self, confTbl, parsed, line):
        "add or update a Conf object given a parsed line"
        db = parsed.group(1)
        cdna = None
        if parsed.group(2) == "refseq":
            cdna = CDnaTypes.refSeq
        elif parsed.group(2) == "genbank":
            if parsed.group(3) == "mrna":
                cdna = CDnaTypes.mrna
            elif parsed.group(3) == "est":
                cdna = CDnaTypes.splicedEst
        state = None
        if parsed.group(5) == "yes":
            state = True
        elif parsed.group(5) == "no":
            state = False
        if (cdna == None) or (state == None):
            raise Exception("can't parse genbank.conf line: "+line)
        conf = self.__obtainConf(db, confTbl)
        if state:
            conf.on.add(cdna)
        else:
            conf.off.add(cdna)

class ChainTbl(list):
    "table of Chains objects between assemblies"
    def __init__(self, dbInfoTbl):
        # entries are dicts for the srcDb, linked to Chain objects
        self.bySrcDb = dict()
        for srcDb in dbInfoTbl.itervalues():
            for destDb in dbInfoTbl.itervalues():
                if destDb.dbOrg != srcDb.dbOrg:
                    self.__addChainsIf(srcDb, destDb)

    def getChain(self, srcDb, destDb):
        forSrcDb = self.bySrcDb.get(srcDb)
        if forSrcDb != None:
            chain = forSrcDb.get(destDb)
            if chain != None:
                return chain
        return None

    def haveChain(self, srcDb, destDb):
        return self.getChain(srcDb, destDb) != None

    def __addChainsIf(self, srcDb, destDb):
        "search for and add a srcDb, destDb chain, if available"
        chains = Chains(srcDb, destDb)
        if chains.setup():
            forSrcDb = self.bySrcDb.get(srcDb)
            if forSrcDb == None:
                forSrcDb = self.bySrcDb[srcDb] = dict()
            forSrcDb[destDb] = chains
            self.append(chains)

    def dump(self, fh):
        prRowv(fh, "ChainTbl")
        for chain in self:
            prRowv(fh, "", chain)

def getSrcDbs(dbInfoTbl, cdnaInfoTbl):
    "get list of databses in info table with cDNAs to map"
    srcDbs = set()
    for dbName in cdnaInfoTbl.iterkeys():
        db = dbInfoTbl.get(dbName)
        if db != None:
            srcDbs.add(db)
    return srcDbs

def getDestDbsChains(dbInfoTbl, srcDbs, chainTbl):
    "get dbs that can be mapped from srcDbs and associatd chains"
    destDbs = set()
    chains = set()
    for ch in chainTbl:
        if (ch.srcDb in srcDbs) and (ch.destDb.db in dbInfoTbl):
            destDbs.add(ch.destDb)
            chains.add(ch)
    return (destDbs, chains)

def buildGenomeDefs(dbInfoTbl, cdnaInfoTbl, chainTbl):
    srcDbs = getSrcDbs(dbInfoTbl, cdnaInfoTbl)
    destDbs, chains = getDestDbsChains(dbInfoTbl, srcDbs, chainTbl)
    defs = GenomeDefs()
    for db in srcDbs:
        db.cdnaTypes = cdnaInfoTbl[db.db]
        defs.addGenomeDb(db)
    empty = frozenset()
    for db in destDbs:
        if db not in srcDbs:
            db.cdnaTypes = empty
            defs.addGenomeDb(db)
    for ch in chains:
        defs.addChains(ch)
    defs.finish()
    return defs

opts = CmdOpts()
dbInfoTbl = DbInfoTbl(opts.includeClades, opts.excludeClades,
                      opts.excludeDbs)
if opts.debug:
    dbInfoTbl.dump(sys.stderr)
cdnaInfoTbl = CDnaInfoTbl()
if opts.debug:
    cdnaInfoTbl.dump(sys.stderr)
chainTbl = ChainTbl(dbInfoTbl)
if opts.debug:
    chainTbl.dump(sys.stderr)

defs = buildGenomeDefs(dbInfoTbl, cdnaInfoTbl, chainTbl)
if opts.debug:
    defs.dump(sys.stderr)
if opts.info != None:
    fh = open(opts.info, "w")
    defs.dump(fh)
    fh.close()

fh = open(opts.pickleOut, "w")
cPickle.dump(defs, fh)
fh.close()
