#!/usr/bin/env python

import sys, os
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.append(myBinDir + "/../extern/pycbio/lib")
sys.path.append(myBinDir + "/../lib/py")
from optparse import OptionParser
from pycbio.sys import fileOps, Pipeline
from transMap import GenomeDefs, getTmpExt
from transMap.GenomeDefs import ChainType
from transMap.TransMap import TransMap, ChromsCache, CDnaPartitionsCache
from transMap.MappingDefs import MappingDefsBuild

# N.B. chrom ranges not very useful now that using overlapSelect
useGenomePart = False

# used in grouping small jobs
genomePartTargetSize = 250000000
genomePartMaxPerJob = 25000

# used to split source cDNA alignments
# hg18 splicedEsts: 2,390,677,424
#  cdnaTargetSize = 250000 too small, really hit hive hard 
cdnaTargetSize = 1000000

class CmdOpts(object):
    usage = """%prog [options] genomeDefsPickle alignBatchDir filterBatchDir tmpOutDir resultsDir
     builds two batches, once to do the alignments, the other to filter and combine
     the results
     """
    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        MappingDefsBuild.addOptions(parser)
        parser.add_option("--synDist", dest="synDist", action="store", default=None, type="float",
                          help="use syntenic filter for genomes with a distance that is no more than this cutoff")
        parser.add_option("--useAvailableRBest", dest="useAvailableRBest", action="store_true", default=False,
                          help="use reciprocal best chains when available for filtering")
        (opts, args) = parser.parse_args()
        if len(args) != 5:
            parser.error("wrong number of arguments")
        (self.genomeDefsPickle, self.alignBatchDir, self.filterBatchDir, self.tmpOutDir, self.resultsDir) = args
        self.__dict__.update(opts.__dict__)

class Batch(object):
    def __init__(self, binDir, batchDir):
        self.binDir = binDir
        self.batchFile = batchDir + "/jobs.para"
        self.batchFileTmp = self.batchFile + getTmpExt()
        fileOps.ensureDir(batchDir)
        self.fh = open(self.batchFileTmp, "w")

    def addJob(self, cmd):
        out = cmd[-1]
        cmd2 = [self.binDir + "/" + cmd[0]] + list(cmd[1:-1]) + ["{check out exists " + out + "}"]
        fileOps.prLine(self.fh, " ".join(cmd2))

    def close(self):
        self.fh.close()
        os.rename(self.batchFileTmp, self.batchFile)

class MkJobs(object):
    def __init__(self, opts):
        mdefsBld = MappingDefsBuild(opts);
        self.gdefs = mdefsBld.defs
        self.mdefs = mdefsBld.mappings
        self.synDist = opts.synDist
        self.useAvailableRBest = opts.useAvailableRBest
        self.alignBat = Batch(myBinDir, opts.alignBatchDir)
        self.filterBat = Batch(myBinDir, opts.filterBatchDir)
        self.transMap = TransMap(None, self.gdefs, ".", self.mdefs, opts.tmpOutDir)
        self.chromsCache = ChromsCache("/cluster/data")
        self.cdnaPartsCache = CDnaPartitionsCache(self.transMap, cdnaTargetSize)

    def close(self):
        self.alignBat.close()
        self.filterBat.close()

    def __getChainType(self, chainsSet):
        if (self.synDist != None) and (chainsSet.dist != None) and (chainsSet.dist <= self.synDist):
            if self.useAvailableRBest and (ChainType.rbest in chainsSet.byType):
                return ChainType.rbest
            else:
                return ChainType.syn
        else:
            return ChainType.all
        
    def __mkAlignJob(self, mapping, cdnaPart, genomePart, outPsl):
        cmd = ["doRunTransMap"]
        if genomePart != None:
            if genomePart[0] == genomePart[1]:
                cmd.append("--chrom="+genomePart[0])
            else:
                cmd.append("--firstChrom="+genomePart[0])
                cmd.append("--lastChrom="+genomePart[1])
        cmd.extend((opts.genomeDefsPickle, mapping.srcDb.name, mapping.destDb.name,
                    str(self.__getChainType(mapping.chainsSet)), str(mapping.cdnaType), cdnaPart,
                    self.transMap.clusterDir, outPsl))
        self.alignBat.addJob(cmd)

    def __doAlignPart(self, mapping, cdnaPart, genomePart):
        genomePart0 = genomePart[0] if (genomePart != None) else None
        outPsl = self.transMap.getClusterMappedPsl(mapping.destDb, mapping.srcDb, mapping.cdnaType, cdnaPart, genomePart0)
        if not os.path.exists(outPsl):
            self.__mkAlignJob(mapping, cdnaPart, genomePart, outPsl)

    def __doAlign(self, mapping):
        # partition genome and cdnas
        if useGenomePart:
            genomeParts = self.chromsCache.obtain(mapping.destDb).partition(genomePartTargetSize, genomePartMaxPerJob)
        else:
            genomeParts = [None]
        cdnaParts = self.cdnaPartsCache.obtain(mapping.srcDb, mapping.cdnaType)
        for genomePart in genomeParts:
            for cdnaPart in cdnaParts.parts:
                self.__doAlignPart(mapping, cdnaPart, genomePart)

    def __mkFilterJob(self, mapping, outPsl):
        cdnaParts  = self.cdnaPartsCache.obtain(mapping.srcDb, mapping.cdnaType)
        self.filterBat.addJob(("doRunFilter", opts.genomeDefsPickle, mapping.srcDb.name, mapping.destDb.name, str(mapping.cdnaType), cdnaParts.partList, self.transMap.clusterDir, outPsl))

    def __doMapping(self, mapping):
        outPsl = self.transMap.getMappedPsl(mapping.destDb, mapping.srcDb, mapping.cdnaType)
        if not os.path.exists(outPsl):
            self.__doAlign(mapping)
            self.__mkFilterJob(mapping, outPsl)

    def genJobs(self):
        for destDbMappings in self.mdefs:
            for mapping in destDbMappings.mappingsBySrcDb.itervalues():
                self.__doMapping(mapping)

opts = CmdOpts()
mkJobs = MkJobs(opts)
mkJobs.genJobs()
mkJobs.close()
