#!/usr/bin/env python

import sys, os
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.append(myBinDir + "/../extern/pycbio/lib")
sys.path.append(myBinDir + "/../lib/py")
execPath = myBinDir + "/../output/bin/" + os.uname()[4] + "/opt"
os.environ["PATH"] = execPath + ":" + myBinDir +":"+ os.environ["PATH"]

from optparse import OptionParser
from pycbio.sys import fileOps, Pipeline, procOps
from transMap import GenomeDefs, setTMPDIR, getTmpExt, runCmds, copyFile
from transMap.GenomeDefs import ChainType
from transMap.TransMap import TransMap,Chroms

class CmdOpts(object):
    usage = """%prog [options] genomeDefsPickle srcDb destDb chainType cdnaType cdnaPart clusterDir mappedPsl"""
    def __init__(self):
        parser = OptionParser(usage=CmdOpts.usage)
        parser.add_option("--chrom", dest="chroms", action="append", default=None,
                          help="only process this destination chrom, maybe repeated")
        parser.add_option("--firstChrom", dest="firstChrom", action="store", default=None,
                          help="destDb start destination chrom in reverse size sort list")
        parser.add_option("--lastChrom", dest="lastChrom", action="store", default=None,
                          help="destDb last destination chrom in reverse size sort list")
        parser.add_option("--keep", dest="keep", action="store_true", default=False,
                          help="keep temporary files")
        (opts, args) = parser.parse_args()
        if len(args) != 8:
            parser.error("wrong number of arguments: got " + str(len(args)) + ", expect 8")
        (self.genomeDefsPickle, self.srcDb, self.destDb, self.chainType, self.cdnaType, self.cdnaPart, self.clusterDir, self.mappedPsl) = args
        self.__dict__.update(opts.__dict__)
        if ((opts.firstChrom != None) or (opts.lastChrom != None)) and ((opts.firstChrom == None) or (opts.lastChrom == None)):
            parser.error("must specified either both or neither of --firstChrom and --lastChrom")

    def fixEnums(self):
        # FIXME: don't convert Enumerations until GenomeDefs is loaded
        self.chainType = GenomeDefs.ChainType(self.chainType)
        self.cdnaType = GenomeDefs.CDnaType(self.cdnaType)

def bldChroms(opts, dest2bit):
    chromSet = None
    if (opts.chroms != None) or (opts.firstChrom != None):
        chromSet = []
        if opts.chroms != None:
            chromSet.extend(opts.chroms)
        if (opts.firstChrom != None):
            chroms = Chroms(dest2Bit)
            chromSet.extend(chroms.getRange(opts.firstChrom, opts.lastChrom))
    return chromSet

# memory optimizations:
#   - limit cDNA fasta sequences read by pslRecalcMatch step to those that aligned
#   - limit chains read by netChainSubset, since it reads all chains into memory

opts = CmdOpts()
tmpDir = setTMPDIR()
tmpExt = getTmpExt()

###
# skip if already completed
###
if os.path.exists(opts.mappedPsl):
    sys.stderr.write("Note: output already exists, skipping: " + opts.mappedPsl + "\n")
    sys.exit(0)

genomeDefs = GenomeDefs.load(opts.genomeDefsPickle)
opts.fixEnums()
transMap = TransMap(None, genomeDefs, ".", None, opts.clusterDir)
srcDb = genomeDefs.dbs[opts.srcDb]
destDb = genomeDefs.dbs[opts.destDb]

##
# input
##

# chains
chainsSet = srcDb.destChainsSets.getChainsSet(destDb)

# cDNA
srcPsl = transMap.getClusterSrcPsl(srcDb, opts.cdnaType, opts.cdnaPart)
srcFa = transMap.getClusterSrcFa(srcDb, opts.cdnaType, opts.cdnaPart)

# genome sequence
relTargetSeqs = destDb.name + "/" + destDb.name + ".2bit"
targetSeqs = "/scratch/data/" + relTargetSeqs
if not os.path.exists(targetSeqs):
    targetSeqs = "/hive/data/genomes/" + relTargetSeqs
if not os.path.exists(targetSeqs):
    raise Exception("can't find genome: " + targetSeqs)
if (opts.chroms != None) or (opts.firstChrom != None):
    chroms = bldChroms(opts, targetSeqs)
else:
    chroms = None


##
# intermediate output
##
chainSubsetTmp = tmpDir + "/transmap.chain" + tmpExt
pslRawTmp = tmpDir + "/transmap.psl" + tmpExt
mapInfoRawTmp = tmpDir+ "/transmap.mapinfo.raw" + tmpExt
pslPreFiltTmp = tmpDir+ "/transmap.psl.prefilt" + tmpExt
mapInfoPreFiltTmp = tmpDir+ "/transmap.mapinfo.prefilt" + tmpExt
pslFiltTmp = tmpDir+ "/transmap.psl.filt" + tmpExt
mapInfoFiltTmp = tmpDir+ "/transmap.mapinfo.filt" + tmpExt
pslRecalcTmp = tmpDir+ "/transmap.psl.recalc" + tmpExt

tmpFiles = (chainSubsetTmp, pslRawTmp, mapInfoRawTmp, pslPreFiltTmp, mapInfoPreFiltTmp, pslFiltTmp, mapInfoFiltTmp, pslRecalcTmp)

# output
outPrefix = os.path.splitext(fileOps.uncompressedBase(opts.mappedPsl))[0]
outPslTmp = opts.mappedPsl + tmpExt
outMapInfo = outPrefix + ".mapinfo"

###
# Get the chains to use.   Pre-filter with overlapSelect to reduce
# memory requirements of pslMap and netChainSubset.
###
chains = chainsSet.getSupportingType(opts.chainType)
if chains == None:
    chainsSet.dump(sys.stderr)
    raise Exception("No chains found for type: "+ str(opts.chainType))

chainPreFiltCmds = []
chainPreFiltCmds.append(["overlapSelect", "-inFmt=chainq", srcPsl, chains.chainFile, "/dev/stdout"])
if chroms != None:
    chainPreFiltCmds.append(["chainFilter", "-noHap", "-t=" + ",".join(chroms), "/dev/stdin"])
else:
    chainPreFiltCmds.append(["chainFilter", "-noHap", "stdin"])
runCmds(chainPreFiltCmds, stdout=chainSubsetTmp)

chainFilterCmds = []
if (opts.chainType == ChainType.all) or (opts.chainType == ChainType.rbest):
    # no filtering
    chainInFileRef = chainSubsetTmp
else:
    # syn filtering
    chainFilterCmds.append(["netFilter", "-syn", "-noHap", chains.netFile])
    chainFilterCmds.append(["netChainSubset", "-wholeChains", "-skipMissing", "-verbose=0", "/dev/stdin", chainSubsetTmp, "/dev/stdout"])
    chainInFileRef = "/dev/stdin"

###
# map alignments, removing duplicate psls with same query/target range, which
# are noise and make it difficult to select the right mapInfo records
##
pslMap = ["pslMap", "-chainMapFile", "-mapInfo="+mapInfoRawTmp, srcPsl, chainInFileRef, pslRawTmp]
runCmds(chainFilterCmds +[pslMap])
preFilt = ["pslMapInfoPreFilter", "-chainSubset="+str(opts.chainType), pslRawTmp, mapInfoRawTmp, pslPreFiltTmp, mapInfoPreFiltTmp]
runCmds(preFilt)

###
# Filter before pslRecalcMatch to avoid it take hours when there are huge
# number of mappings (say > 50,000 for one refseq in mapped to monDom5).
# Target sort speeds up pslRecalcMatch.
##
pslCDnaFilter = ["pslCDnaFilter", "-verbose=0", "-minQSize=" + str(transMap.minQSize), "-minCover=" + str(transMap.minCover),
                 "-globalNearBest=" + str(transMap.getGlobalNearBestPreFilter(destDb)), pslPreFiltTmp, "stdout"]
tsort = ["sort","-k","14,14", "-k", "16,16n"]
runCmds([pslCDnaFilter, tsort], stdout=pslFiltTmp)

# select subset of alignments and get matching mapInfo file
pslMapInfoSelect = ["pslMapInfoSelect", mapInfoPreFiltTmp, pslFiltTmp, mapInfoFiltTmp]
runCmds(pslMapInfoSelect)

###
# calculate match stats; qsort here, just to make runFilter qsort a bit quicker.
##
pslRecalcMatch = ["pslRecalcMatch", "-ignoreQUniq", pslFiltTmp, targetSeqs,
                  transMap.getClusterSrcFa(srcDb, opts.cdnaType, opts.cdnaPart), "/dev/stdout"]

qsort = ["sort", "-k","10,10", "-k", "12,12n", "-k", "13,13n"]
runCmds([pslRecalcMatch, qsort], stdout=pslRecalcTmp)

# install files, psl last and atomic
fileOps.ensureFileDir(opts.mappedPsl)
copyFile(mapInfoFiltTmp, outMapInfo)
copyFile(pslRecalcTmp, outPslTmp)
os.rename(outPslTmp, opts.mappedPsl)

if opts.keep:
    sys.stderr.write("Note: keeping temporary files:\n")
    for f in tmpFiles:
        sys.stderr.write("\t" + f + "\n")
else:
    for f in tmpFiles:
        os.unlink(f)
